# -*- coding: utf-8 -*-
"""Facial Emotions Detection.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1e373TcfHu0_djuH0YazqozAZPJW09L6G
"""

from google.colab import drive
drive.mount('/content/drive')

# Commented out IPython magic to ensure Python compatibility.
# %cd /content/drive/MyDrive/Facial expression

import tarfile

fname = 'fer2013.tar.gz'
if fname.endswith("tar.gz"):
    tar = tarfile.open(fname, "r:gz")
    tar.extractall()
    tar.close()
elif fname.endswith("tar"):
    tar = tarfile.open(fname, "r:")
    tar.extractall()
    tar.close()

import os
import numpy as np
import pandas as pd
import tensorflow as tf
from matplotlib import pyplot

df=pd.read_csv('fer2013/fer2013.csv')
df.head()

df.emotion.unique()

label_to_text = {0:'anger', 1:'disgust', 2:'fear', 3:'happiness', 4: 'sadness', 5: 'surprise', 6: 'neutral'}

np.array(df.pixels.loc[0].split(' ')).reshape(48,48)

pyplot.imshow(np.array(df.pixels.loc[0].split(' ')).reshape(48,48).astype('float'))

fig = pyplot.figure(1, (14, 14))
k = 0
for label in sorted(df.emotion.unique()):
    for j in range(3):
        px = df[df.emotion==label].pixels.iloc[k]
        px = np.array(px.split(' ')).reshape(48, 48).astype('float32')
        k += 1
        ax = pyplot.subplot(7, 7, k)
        ax.imshow(px)
        ax.set_xticks([])
        ax.set_yticks([])
        ax.set_title(label_to_text[label])
        pyplot.tight_layout()

img_array = df.pixels.apply(lambda x : np.array(x.split(' ')).reshape(48,48,1).astype('float32'))

img_array = np.stack(img_array,axis=0)

labels = df.emotion.values

from sklearn.model_selection import train_test_split

X_train,X_test,y_train,y_test = train_test_split(img_array,labels,test_size=.1)

X_train.shape,y_train.shape,X_test.shape,y_test.shape

X_train = X_train/255
X_test = X_test/255

basemodel=tf.keras.models.Sequential([tf.keras.layers.Conv2D(32,(3,3),activation='relu',input_shape = (48,48,1)),
                                      tf.keras.layers.MaxPool2D(2,2),
                                      #
                                      tf.keras.layers.Conv2D(64,(3,3),activation='relu',input_shape = (48,48,1)),
                                      tf.keras.layers.MaxPool2D(2,2),
                                      #
                                      tf.keras.layers.Conv2D(128,(3,3),activation='relu',input_shape = (48,48,1)),
                                      tf.keras.layers.MaxPool2D(2,2),
                                      #
                                      tf.keras.layers.Conv2D(256,(3,3),activation='relu',input_shape = (48,48,1)),
                                      tf.keras.layers.MaxPool2D(2,2),
                                      tf.keras.layers.Flatten(),
                                      tf.keras.layers.Dense(1000,activation='relu'),
                                      tf.keras.layers.Dense(7,activation='softmax')
                                      ])

basemodel.summary()

basemodel.compile(optimizer=tf.keras.optimizers.RMSprop(learning_rate=.0001),
                  loss = tf.keras.losses.SparseCategoricalCrossentropy(from_logits=True),
                  metrics =['accuracy'])

import os
try:
  os.mkdir('checkpoint')
except:
  pass

file_name = 'best_model.h5'
checkpoint_path= os.path.join('checkpoint',file_name)

call_back = tf.keras.callbacks.ModelCheckpoint(filepath=checkpoint_path,
                                                 monitor='val_accuracy',
                                                 verbose=1,
                                                 save_freq='epoch',
                                                 save_best_only=True,
                                                 save_weights_only=False,
                                                 mode='max')

basemodel.fit(X_train,y_train, epochs=50,validation_split=.2,callbacks=call_back)

X_train.shape

final_model = tf.keras.models.load_model(checkpoint_path)
from IPython.display import clear_output
import time
for k in range(40):
  print(f'actual label is {label_to_text[y_test[k]]}')
  predicted_class = final_model.predict(tf.expand_dims(X_test[k],0)).argmax()
  print(f'predicted label is {label_to_text[predicted_class]}')
  pyplot. imshow(X_test[k].reshape((48,48)))
  pyplot.show()
  time.sleep(5)
  clear_output(wait=True)